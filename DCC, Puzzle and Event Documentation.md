# DCC, Puzzle and Event Documentation

This documentation explains how to write code in the DCC language for puzzles and events in the Layton Editor.

Contents:
* DCC Syntax
* Puzzle Structure
* Event Structure


# DCC Syntax

DCC is a language created to store gds scripts in a human-readable way. The name means from `Data and Code Container` due to its ability to hold both data and code together.

DCC data can be of the following types:
* string (delimited by quotes)
* int (decimal or hexadecimal preceded by 0x)
* float
* bool (true or false)
* null

The content of a DCC file is divided into groups. Groups are defined like:

```
group_name: [
    <group data>
]
```

Comments can also be added with `#`.

Each group can hold 3 different content: unnamed data, named data and calls.

## Unnamed Data

Unnamed data is data for which the order matters. It's the equivalent of list data. An example within a group would be:

```
group_unnamed: [
    ="Unnamed data"
    ="Unnamed data2"
]
```

## Named data

Named data is data for which the order doesn't matter, but rather the identifiers. It's the equivalent of dictionary data. An example within a group would be:

```
group_named: [
    named_1: "data"
    named_2: "data2"
]
```

## Calls
Calls are what hold the actual code of the script. Calls can have unnamed parameters, but can't have named nor calls as parameters. An example of a call within a group would be:

```
script: [
    call_1("param_1", "param_2")
]
```

## Using previously defined named variables

Named variables can be referenced in function calls and they will take the same value as the declaration. This can be used to avoid having to change all values throughout the code.

Note: when compiling this references will be lost.

Example:
```
group: [
    var1: 10
    var2: 20
]

script_test: [
    # Will be replaced with call_2(10, 20)
    call_2(group.var1, group.var2)
]
```

# Puzzles

Puzzle DCC generated by the Layton Editor have the following groups:
```
pzd: [
    # This group holds all the data about the puzzle
]

pzs: [
    # This group holds all the code for the puzzle
]
```

## PZD (Puzzle Data)
This group has the following named data:

| Name | Type | Description
| :-- | :---: | ---:
| title | string | The title of the puzzle
| type | int | The type of puzzle
| number | int | The number which represents the puzzle ingame
| location_id | int | The id for the top and end screens design
| tutorial_id | int |
| reward_id | int
| bg_btm_id | int | The id for the bottom background
| bg_top_id | int | The id for the top background
| judge_char | int | The character which appears after the puzzle is submitted (1 or 0)
| flag_bit2 | bool
| flag_bit5 | bool
| bg_lang | bool | Weather the path for the background depends on the language
| ans_bg_land | bool | Weather the path for the answer background depends on the language
| picarat_decay | group (3 unnamed) | The values for the picarats when the puzzle is failed
| text | string | The explanation text for the puzzle
| correct_answer | string | The text at the end when the puzzle is solved
| incorrect_answer | string | The text at the end when the puzzle is failed
| hint1 | string | The text for the first hint
| hint2 | string | The text for the second hint
| hint3 | string | The text for the third hint

Example:
```
pzd: [
    title: "Puzzle Title"
    type: 26
    number: 1
    location_id: 91
    tutorial_id: 2
    reward_id: 255
    bg_btm_id: 1
    bg_top_id: 1
    judge_char: 0
    flag_bit2: true
    flag_bit5: true
    bg_lang: false
    ans_bg_lang: false
    picarat_decay: [
        =10
        =9
        =8
    ]
    text: "Explanation text"
    correct_answer: "Excellent work!"
    incorrect_answer: "Too bad!"
    hint1: "First hint"
    hint2: "Second hint"
    hint3: "Third hint"
]
```

## PZS (Puzzle Script)

This group hold the commands for the gds script. If the command is not recognized or there is no parser for the type of puzzle, the gds call will have the name `gds_<command hex>`, like `gds_0x60`.

Example:
```
pzs: [
    gds_0x60()
    gds_0x55(80, 32)
    gds_0x55(48, 64)
    gds_0x55(80, 64)
]
```

### Puzzle Type: Input

| Command | Parameters | Description
| :- | :--: | -:
| load_input_bg | path: string | Set the path for the background in which the answer will be written.
| set_input_type | unk0: int, unk1: int, unk2: int, type of input: int | Set the type of answer
| set_answer | answer_number: int (0), answer: string | Set the answer for the puzzle

Examples:
```
pzs: [
    load_input_bg("?/q11_input.bgx")
    set_input_type(0, 40, 20, 2)
    set_answer(0, "64")
]
```
```
pzs: [
    load_input_bg("drawinput2.bgx")
    set_input_type(0, 80, 20, 2)
    set_answer(0, "04")
]
```

### Puzzle Type: Multiple Choice

| Command | Parameters | Description
| :- | :-: | -:
| add_button | x: int, y: int, path: string, is_solution: int (0/1), unk0: int (0) | Add a button with the sprite path. If is_solution is 1, the button will be a solution to the puzzle.

Example: 
```
pzs: [
    add_button(8, 21, "freebutton_m.spr", 0, 0)
    add_button(64, 21, "freebutton_m.spr", 0, 0)
    add_button(127, 21, "freebutton_m.spr", 0, 0)
    add_button(64, 106, "freebutton_m.spr", 1, 0)
    add_button(127, 106, "freebutton_m.spr", 0, 0)
]
```

## Complete Puzzle Example

```
pzd: [
    title: "Entryway Engima"
    type: 22
    number: 10
    location_id: 11
    tutorial_id: 1
    reward_id: 255
    bg_btm_id: 9
    bg_top_id: 2
    judge_char: 0
    flag_bit2: true
    flag_bit5: true
    bg_lang: false
    ans_bg_lang: false
    picarat_decay: [
        =15
        =13
        =11
    ]
    text: "\"So you see, I was the other day trying\n
to get into a club, but it seems there's a\n
password! I was listening for sometime and\n
I overheard that a #r6 corresponds to a 3\n
and that a 12 corresponds to a 6.#x\n
\n
They gave me the numbers 10-12-8 and I,\n
who though had cracked the code, answered\n
5-6-4, but to my surprise, it was\n
incorrect!\"\n
\n
What was the answer I should've given?"
    correct_answer: "Indeed, the response to 10-12-8 should\n
be [REDACTED]!"
    incorrect_answer: "The connection is quite easy once you\n
know the answer.\n
\n
Remember, it's not 5-6-4!"
    hint1: "[REDACTED]"
    hint2: "[REDACTED]"
    hint3: "[REDACTED]"
]
pzs: [
    load_input_bg("drawinput3.bgx")
    set_input_type(0, 0, 0, 3)
    set_answer(0, "123")
]
```

## Puzzle Types Appendix

The possible puzzle types are:
* Multiple Choice: 0
* Mark Answer: 3
* Circle Answer: 5
* Draw Line Plaza: 6 (?)
* Line Divide: 9
* Sort: 0xA
* Weather: 0xB (?)
* Piles Of Pancakes: 0xD
* Line Divide Limited: 0xF
* Input Alphabet: 0x10
* Knight Tour: 0x11
* Tile Rotate: 0x12
* Input Numbers: 0x16
* Area: 0x17 (?)
* Roses: 0x18
* Slide: 0x19
* Tile Rotate 2: 0x1A (?)
* Slippery Crossings: 0x1B
* Input Alternative: 0x1C (?)
* Disappearing Act: 0x1D
* Jars and Cans: 0x1E
* Light the Way: 0x1F
* Rickety Bridge: 0x21
* Find Shape: 0x22
* Input Date: 0x23 (?)

# Events

Event DCC generated by the Layton Editor have the following groups:
```
evdat: [
    # This group holds all the data about the event
]
evs: [
    # This group holds all the code for the event
]
```

## EVDAT (Event Data)

This group has the following named data:

| Name | Type | Description
| :- | :-: | -:
| map_top_id | int | The id for the top map image of the screen. Corresponds to `data_lt2/bg/event/sub<id>.arc`
| map_btm_id | int | The id for the bottom map image of the screen. Corresponds to `data_lt2/bg/map/main<id>.arc`
| char# | groups | The data for the characters

Each character has the following named data:
| Name | Type | Description
| :- | :-: | -:
| char | int | The id of the character
| pos | int | The slot it occupies when the event starts
| shown | bool | Wether the character is shown when the event starts
| anim | int | The index of the animation when the event starts

Note: There have to be 8 characters, from 0 to 7.

Example:
```
evdat: [
    map_top_id: 0
    map_btm_id: 1
    characters: [
    ]
    char0: [
        char: 1
        pos: 0
        shown: false
        anim: 1
    ]
    char1: [
        char: 2
        pos: 2
        shown: false
        anim: 1
    ]
    char2: [
        char: 3
        pos: 0
        shown: true
        anim: 1
    ]
    char3: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
    char4: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
    char5: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
    char6: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
    char7: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
]
```

## EVS (Event Script)

This group holds the commands for the event gds script. If the command is not recognized or there is no parser for the type of puzzle, the gds call will have the name `gds_<command hex>`, like `gds_0x60`.

| Command | Parameters | Description
| :- | :-: | -:
| dial | text_gds_num: int, char_id: int, anim_start: str, anim_end: str, unk0: int, dialogue_text: str | Start a dialogue with the specified character. The initial animation will be `anim_start` and the end animation will be `anim_end`. The text_gds_num should increase in intervals of 100 in an event (100, 200, 300...).
| fade | fade_in: bool, fade_screen: int, fade_time: int or null | Fades the screen. The first argument determines if the screen will be faded in or faded out, true being a fade in. The second argument is the screen in which to cause the fade (0: bottom screen, 1: top screen, 2: both screens). The third argument is the number of frames it will take to fade the screen, or null if you want to use the default.
| bg_load | path: str, screen: int | Loads a background into the screen. The first argument is the path of the background to load. The second argument is the screen in which to load the background(0: bottom screen, 1: top screen). The path will be `data_lt2/bg/<path>`.
| set_mode | mode: str | Sets the mode which will be loaded after the event. It's needed before setting the next event, puzzle or movie.
| set_next_mode | mode: str | Sets the mode which will be loaded after the mode in set_mode has completed. Can be used to chain events, like setting an event to trigger after a movie.
| set_movie | movie_id: int | Sets the movie id which will play in the next movie mode.
| set_event | event_id: int | Sets the event id which will play in the next event mode.
| set_puzzle | puzzle_id: int | Sets the puzzle id which will play in the next puzzle mode.
| chr_show | char_index: int | Shown the character in the specified index.
| chr_hide | char_index: int | Hides the character in the specified index.
| chr_visibility | char_index: int, show: bool | Shows or hides the character in the specified index.
| chr_slot | char_index: int, slot: int | Sets the slot for the character in the specified index.
| chr_anim | char_id: int, anim: str | Set the animation of the character with the specified id to the specified animation.
| show_chapter | chapter_num: int | Shows the specified chapter.
| wait | time: int | Waits the number of frames specified as the parameter before continuing.
| bg_opacity | unk0: int, unk1: int, unk2: int, opacity: int | Sets the opacity of the fader of the bottom screen (from 0 to 255 maybe).
| set_voice | voice_id: int | Sets the id of the next voice line that has to be played with the next dialogue.
| sfx_sad | sfx_id: int | Play the sad sound effect with the specified id.
| bg_music | music_id: int, volume: float, unk0: int | Play the specified music at the specified volume (between 0.0 and 1.0). Unk0 can be left at 0. The path for the music will be `data_lt2/sound/BG_<id>.SWD`.
| bg_shake | | Shake the bottom background

Tip: the previewer can help you test dialogues, although it's not 100% accurate. Also, sequenced and synthesized music, like BG music. Only SAD sound effects can be played.

Example:
```
evs: [
    dial(100, 1, "NONE", "NONE", 2, "...Hmm?")
    fade(false, 0, null)
    chr_show(2)
    chr_show(3)
    chr_hide(0)
    fade(true, 0, null)
    dial(200, 28, "NONE", "NONE", 3, "Ooooh, Mr Beluga, it's been ages!\n
I haven't seen you in donkey's! Did\n
you find that thing in the end?")
    dial(300, 9, "NONE", "NONE", 2, "Hmph, I wish. I told Sam to track it\n
down, but that boy is about as\n
useful as a chocolate frying pan.")
    dial(400, 28, "NONE", "NONE", 3, "Oooh, don't fret like that, love.\n
You'll get wrinkles in that\n
distinguished brow of yours.@p@c'Ey up then, Mr B, duck. How about\n
coming inside for a catch-up?")
    fade(false, 0, null)
    chr_hide(2)
    chr_hide(3)
    chr_show(0)
    chr_show(1)
    fade(true, 0, null)
    dial(500, 2, "NONE", "NONE", 3, "Professor, did you see that?\n
Mr Beluga just went into that\n
cabaret.")
    dial(600, 1, "NONE", "NONE", 2, "Let's take a closer look, shall we?")
]
```

## Complete Event Example

```
evdat: [
    map_top_id: 31
    map_btm_id: 59
    characters: [
    ]
    char0: [
        char: 26
        pos: 0
        shown: true
        anim: 1
    ]
    char1: [
        char: 32
        pos: 2
        shown: true
        anim: 1
    ]
    char2: [
        char: 0
        pos: 0
        shown: false
        anim: 1
    ]
    char3: [
        char: 0
        pos: 2
        shown: false
        anim: 1
    ]
    char4: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
    char5: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
    char6: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
    char7: [
        char: 0
        pos: 0
        shown: false
        anim: 0
    ]
]
evs: [
    dial(100, evdat.char0.char, "b1 normal", "NONE", 2, "
Hey miss, is everything all right?")
    dial(200, evdat.char1.char, "b1 normal", "NONE", 2, "
I have a favor to ask...@p\n
I know you have a good\n
relationship with Anton.@p@c
Could you give this to him?")
    fade(false, 0, null)
    chr_hide(0)
    chr_hide(1)
    bg_load("ebg/ebg_110.arc", 0)
    fade(true, 0, null)
    wait(180)
    fade(false, 0, null)
    chr_show(0)
    chr_show(1)
    bg_load("map/main59.arc", 0)
    bg_opacity(0, 0, 0, 120)
    fade(true, 0, null)
    dial(300, evdat.char0.char, "b2 normal", "NONE", 2, "
Miss, may I ask what is this?")
    dial(400, evdat.char1.char, "b2 normal", "NONE", 2, "
It's... a present.@p&setani 32 b1_normal& Could you\n
make sure that Anton gets his\n
hands on this?")
    dial(500, evdat.char0.char, "b1 normal2", "NONE", 2, "
Don't worry miss.")
    dial(600, evdat.char1.char, "NONE", "NONE", 2, "
Th... Thanks.")
]
```

Note: this event doesn't appear in the actual game.

## In-dialogue Commands

You can add commands in dialogues to perform the following effect:
| Command | Effect
| :-: | -
| @p | Pause until the screen is touched.
| @c | Clear dialogue box.
| &setani char_id anim& | Sets the animation for the character with the specified id to the specified animation. The name of the animation must have underscores (_) instead of spaces: `b1 normal` -> `b1_normal`.
| @s | Unknown

Certain commands will be usually used in succession. For example, `@p@c` is used to wait for a tap before clearing the dialogue box.

## Event Characters Appendix

The IDs for the characters are:
* Layton: 1
* Luke: 2
* Schrader: 3
* Unknown: 4
* Flora: 5
* Chelmey: 6
* Barton: 7
* Sammy: 8
* Beluga: 9
* DonPaolo: 10
* Babette: 11
* Tom: 12
* Chester: 13
* Macaroon: 14
* GrannyR: 15
* Angus: 16
* Clabber: 17
* Cattle: 18
* Romie: 19
* Katia: 20
* Jacques: 21
* Dorothea: 22
* UnnamedMan: 23
* Krantz: 24
* Dawson: 25
* Joseph: 26
* Felix: 27
* Vera: 28
* Nigel: 29
* AntonYoung: 30
* AntonOld: 31
* Sophia: 32
* AntonPast: 33
* Stachen: 34
* Steve: 35
* Lili: 36
* Mitzi: 37
* Capone: 38
* Conrad: 39
* Sally: 40
* Opal: 41
* Grousley: 42
* Marjorie: 43
* Karla: 44
* Grinko: 45
* Damon: 46
* BabetteSleeping: 47
* Oscar: 48
* Parcelle: 49
* Madeline: 50
* Nick: 51
* TrainBack?: 52
* TrainSide?: 53
* Gabe: 54
* Balsa: 55
* Wurtzer: 56
* Laurel: 57
* Lopez: 58
* Clarice: 59
* Lulu: 60
* Albert: 61
* Remy: 62
* Gertie: 63
* Kostya: 64
* Garland: 65
* Geoff: 66
* Dylan: 67
* Rory: 68
* Lila: 69
* Niles: 70
* Duke: 71
* Hopper: 72
* Olson: 73
* Derby: 74
* Joanie: 75
* Marina: 76
* Ray: 77
* Gregorio: 78
* Pavel: 79
* Precious: 80
* LaytonTied: 81
* LukeTied: 82
* AntonOldReading: 83
* Hamster: 84
* Anderson: 85
* Unknown2: 88

## Event Slots Appendix

Slots on the left: 0, 3, 4
Slots on the right: 1 (never used), 2, 5, 6

Slots with offset: 4, 5, 1 (double offset)

## Note on Character Animations

The name of the animations can be found using the sprite editing window. The animations preceeded with "\*" are for when the character is talking, and so cannot be used on events.

